/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.amazonaws.services.dynamodbv2;

import com.amazonaws.services.dynamodbv2.model.LockCurrentlyUnavailableException;
import com.amazonaws.services.dynamodbv2.model.LockNotGrantedException;
import com.amazonaws.services.dynamodbv2.util.LockClientUtils;
import momento.sdk.CacheClient;

import java.io.Closeable;
import java.io.IOException;
import java.time.Duration;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Stream;

public class MomentoLockClient extends AmazonDynamoDBLockClient implements Closeable  {

    private final String lockCacheName;
    private final CacheClient cacheClient;
    private static final long DEFAULT_BUFFER_MS = 1000;
    private final long leaseDurationMillis;
    private final long heartbeatPeriodInMilliseconds;
    private final String owner;
    private final ConcurrentHashMap<String, Thread> sessionMonitors;
    private final LockStorage lockStorage;
    private final Function<String, ThreadFactory> namedThreadCreator;

    private final String partitionKeyName;
    private final Optional<String> sortKeyName;
    private ScheduledExecutorService heartbeatExecutor;
    private MomentoLockClientHeartbeatHandler heartbeatHandler;

    private final MomentoClient momentoClient;
    private final Boolean holdLockOnServiceUnavailable;

    private final ScheduledExecutorService executorService;
    public MomentoLockClient(final MomentoDynamoDBLockClientOptions lockClientOptions) {
        super(AmazonDynamoDBLockClientOptions.builder(new NoopDynamoDbClient(), lockClientOptions.getCacheName()).build());
        Objects.requireNonNull(lockClientOptions.getTableName(), "Table name cannot be null");
        Objects.requireNonNull(lockClientOptions.getCacheName(), "Table name cannot be null");
        Objects.requireNonNull(lockClientOptions.getOwnerName(), "Owner name cannot be null");
        Objects.requireNonNull(lockClientOptions.getTimeUnit(), "Time unit cannot be null");
        Objects.requireNonNull(lockClientOptions.getPartitionKeyName(), "Partition Key Name cannot be null");
        Objects.requireNonNull(lockClientOptions.getSortKeyName(), "Sort Key Name cannot be null (use Optional.absent())");
        Objects.requireNonNull(lockClientOptions.getNamedThreadCreator(), "Named thread creator cannot be null");

        this.lockCacheName = lockClientOptions.getCacheName();

        this.sessionMonitors = new ConcurrentHashMap<>();
        this.owner = lockClientOptions.getOwnerName();
        this.leaseDurationMillis = lockClientOptions.getTimeUnit().toMillis(lockClientOptions.getLeaseDuration());

        this.heartbeatPeriodInMilliseconds = lockClientOptions.getTimeUnit().toMillis(lockClientOptions.getHeartbeatPeriod());
        this.partitionKeyName = lockClientOptions.getPartitionKeyName();
        this.sortKeyName = lockClientOptions.getSortKeyName();
        this.namedThreadCreator = lockClientOptions.getNamedThreadCreator();
        this.holdLockOnServiceUnavailable = lockClientOptions.getHoldLockOnServiceUnavailable();
        this.cacheClient = CacheClient.create(lockClientOptions.getCredentialProvider(),
                lockClientOptions.getConfiguration(), Duration.ofMillis(this.leaseDurationMillis));

        this.momentoClient = new MomentoClient(cacheClient, lockCacheName);
        this.lockStorage = new LockStorage();


        this.heartbeatHandler = new MomentoLockClientHeartbeatHandler(this.lockStorage,
                this.cacheClient, this.lockCacheName, Duration.ofMillis(leaseDurationMillis));

        if (lockClientOptions.getCreateHeartbeatBackgroundThread()) {
            if (this.leaseDurationMillis < 2 * this.heartbeatPeriodInMilliseconds) {
                throw new IllegalArgumentException("Heartbeat period must be no more than half the length of the Lease Duration, "
                        + "or locks might expire due to the heartbeat thread taking too long to update them (recommendation is to make it much greater, for example "
                        + "4+ times greater)");
            }

            this.heartbeatExecutor = new ScheduledThreadPoolExecutor(1);
            heartbeatExecutor.scheduleAtFixedRate(this.heartbeatHandler,
                    0, heartbeatPeriodInMilliseconds, TimeUnit.MILLISECONDS);

        }
        this.executorService = new ScheduledThreadPoolExecutor(10);

    }

    public Stream<LockItem> getAllLocksFromDynamoDB(final boolean deleteOnRelease) {
        throw new UnsupportedOperationException("This operation is not available on" +
                " Momento DynamoDB lock client");
    }

    public Stream<LockItem> getLocksByPartitionKey(String key, final boolean deleteOnRelease) {
        throw new UnsupportedOperationException("This operation is not available on" +
                " Momento DynamoDB lock client");
    }

    public void createLockCache(final String cacheName) {
        momentoClient.createLockCache(cacheName);
    }

    public LockItem acquireLock(final AcquireLockOptions options) throws LockNotGrantedException, InterruptedException {

        final String partitionKey = options.getPartitionKey();
        final Optional<String> sortKey = options.getSortKey();

        String cacheKey = partitionKey;
        if (sortKey.isPresent()) {
            cacheKey = cacheKey + "_" + sortKey.get();
        }

        if (options.getReentrant()) {
            Optional<LockItem> localLock = lockStorage.getLock(cacheKey);
            if (localLock.isPresent()) {
                Optional<MomentoLockItem> lockFromMomento = momentoClient.getLockFromMomento(cacheKey);

                if (lockFromMomento.isPresent() && lockFromMomento.get().getOwner().equals(this.owner)) {
                    return LockItemUtils.fromMomentoLockItem(this, options, lockFromMomento.get());
                }
            }
        }

        validateAttributes(options, partitionKey, sortKey);

        long millisecondsToWait = DEFAULT_BUFFER_MS;
        if (options.getAdditionalTimeToWaitForLock() != null) {
            Objects.requireNonNull(options.getTimeUnit(), "timeUnit must not be null if additionalTimeToWaitForLock is non-null");
            millisecondsToWait = options.getTimeUnit().toMillis(options.getAdditionalTimeToWaitForLock());
        }
        // ddb lock client does this too for default case
        millisecondsToWait += this.leaseDurationMillis;

        long refreshPeriodInMilliseconds = DEFAULT_BUFFER_MS;
        if (options.getRefreshPeriod() != null) {
            Objects.requireNonNull(options.getTimeUnit(), "timeUnit must not be null if refreshPeriod is non-null");
            refreshPeriodInMilliseconds = options.getTimeUnit().toMillis(options.getRefreshPeriod());
        }

        final Optional<SessionMonitor> sessionMonitor = options.getSessionMonitor();
        if (sessionMonitor.isPresent()) {
            sessionMonitorArgsValidate(sessionMonitor.get().getSafeTimeMillis(), this.heartbeatPeriodInMilliseconds,
                    this.leaseDurationMillis);
        }

        try {
            return acquireLockWithRetries(options, cacheKey, millisecondsToWait, refreshPeriodInMilliseconds,
                    options.getTimeUnit());
        } catch (ExecutionException e) {
            throw new RuntimeException(e.getCause());
        }

    }

    private LockItem acquireLockWithRetries(final AcquireLockOptions options, final String cacheKey,
                                            final long totalWaitTime, final long waitTimeIfLockAcquired,
                                            final TimeUnit timeUnit) throws InterruptedException, ExecutionException {

        // supported rvn is constant cacheKey for now
        final LockItem lockItem = new LockItem(this, options.getPartitionKey(), options.getSortKey(), options.getData(), options.getDeleteLockOnRelease(),
                owner, leaseDurationMillis, System.currentTimeMillis(), cacheKey /* rvn */, false, options.getSessionMonitor(),
                options.getAdditionalAttributes());

        final long currentTimeMillis = LockClientUtils.INSTANCE.millisecondTime();

        long delay = 0;

        while (true) {

            final ScheduledFuture<LockItem> future = executorService.schedule(() -> {
                        final Optional<MomentoLockItem> lockFromMomento = momentoClient.getLockFromMomento(cacheKey);

                        if (lockFromMomento.isPresent()) {

                            if (options.getAcquireOnlyIfLockAlreadyExists()) {
                                throw new LockNotGrantedException("Lock does not exist.");
                            }

                            if (options.shouldSkipBlockingWait()) {
                                /*
                                 * The lock is being held by someone else, and the caller explicitly said not to perform a blocking wait;
                                 * We will throw back a lock not grant exception, so that the caller can retry if needed.
                                 */
                                throw new LockCurrentlyUnavailableException("The lock being requested is being held by another client.");
                            }
                        }

                        // todo: serialize only required attributes, and add more if needed
                        boolean acquired = momentoClient.acquireLockInMomento(LockItemUtils.toMomentoLockItem(lockItem));

                        if (acquired) return lockItem;
                        else {
                            if (LockClientUtils.INSTANCE.millisecondTime() - currentTimeMillis > totalWaitTime) {
                                throw new LockNotGrantedException("Didn't acquire lock after sleeping for " + (LockClientUtils.INSTANCE.millisecondTime() - currentTimeMillis) + " milliseconds");
                            }
                            return null;
                        }

                    }, delay, TimeUnit.MILLISECONDS);

            LockItem item = future.get();

            if (item == null) {
                // this will enter only once if the first attempt to acquire the lock failed.
                if (delay == 0) {
                    delay = waitTimeIfLockAcquired;
                }
            } else {
                lockStorage.addLock(cacheKey, item);
                return item;
            }
        }
    }


    private static void validateAttributes(AcquireLockOptions options, String partitionKey, Optional<String> sortKey) {
        if (options.getAdditionalAttributes().containsKey(partitionKey) || options.getAdditionalAttributes().containsKey(OWNER_NAME) || options
                .getAdditionalAttributes().containsKey(LEASE_DURATION) || options.getAdditionalAttributes().containsKey(RECORD_VERSION_NUMBER) || options
                .getAdditionalAttributes().containsKey(DATA) || sortKey.isPresent() && options.getAdditionalAttributes().containsKey(sortKey.get())) {
            throw new IllegalArgumentException(String
                    .format("Additional attribute cannot be one of the following types: " + "%s, %s, %s, %s, %s", partitionKey, OWNER_NAME, LEASE_DURATION,
                            RECORD_VERSION_NUMBER, DATA));
        }
    }

    public boolean hasLock(final String key, final Optional<String> sortKey) {
        String cacheKey = key;
        if (sortKey.isPresent()) {
            cacheKey = cacheKey + "_" + sortKey.get();
        }
        return lockStorage.hasLock(cacheKey);
    }

    public boolean lockTableExists() {
        return momentoClient.lockCacheExists(this.tableName);
    }

    public Optional<LockItem> tryAcquireLock(final AcquireLockOptions options) throws InterruptedException {
        try {
            return Optional.of(this.acquireLock(options));
        } catch (final LockNotGrantedException x) {
            return Optional.empty();
        }
    }

    public Optional<LockItem> getLock(final String key, final Optional<String> sortKey) {
        String cacheKey = key;
        if (sortKey.isPresent()) {
            cacheKey = cacheKey + "_" + sortKey.get();
        }
        Optional<MomentoLockItem> momentoLockItem = momentoClient.getLockFromMomento(cacheKey);
        if (momentoLockItem.isPresent()) {
            // todo: fix me; options cannot be null need to change this signature
            return Optional.of(LockItemUtils.fromMomentoLockItem(this, null, momentoLockItem.get()));
        }
        return Optional.empty();
    }

    public boolean releaseLock(final LockItem lockItem) {
        final String partitionKey = lockItem.getPartitionKey();
        final Optional<String> sortKey = lockItem.getSortKey();

        String cacheKey = partitionKey;
        if (sortKey.isPresent()) {
            cacheKey = cacheKey + "_" + sortKey.get();
        }

        /**
         * When releasing a lock, we aren't explicitly calling delete on momento. We simply remove
         * the lock from being a heartbeating candidate. This essentially means that the lock
         * will be unavailable until it expires. Other threads who want to acquire the lock will block
         * on it until the lease duration expires unless they have been explicitly asked not to. This
         * is better than accidentally calling delete on a lock owned by this client that's already expired
         * but has been acquired by someone else.
         *
         * TODO: call delete on Momento when we can conditionally update/delete an item.
         */
        return lockStorage.removeLock(cacheKey);
    }

    private void releaseAllLocks() {
        /**
         * We do nothing on the backend here until we have conditional deletes. We simply shutdown our
         * heartbeat executor which means that the locks will eventually expire and be available for someone
         * else to acquire it.
         */
        this.heartbeatExecutor.shutdown();
    }

    public void sendHeartbeat(final LockItem lockItem) {
        this.heartbeatHandler.heartBeat(LockItemUtils.toMomentoLockItem(lockItem));
    }

    public void sendHeartbeat(final SendHeartbeatOptions options) {
        Objects.requireNonNull(options, "options is required");
        Objects.requireNonNull(options.getLockItem(), "Cannot send heartbeat for null lock");
        this.sendHeartbeat(options.getLockItem());
    }

    @Override
    public void close() throws IOException {
        this.releaseAllLocks();
        this.cacheClient.close();
    }

    private static void sessionMonitorArgsValidate(final long safeTimeWithoutHeartbeatMillis, final long heartbeatPeriodMillis, final long leaseDurationMillis)
            throws IllegalArgumentException {
        if (safeTimeWithoutHeartbeatMillis <= heartbeatPeriodMillis) {
            throw new IllegalArgumentException("safeTimeWithoutHeartbeat must be greater than heartbeat frequency");
        } else if (safeTimeWithoutHeartbeatMillis >= leaseDurationMillis) {
            throw new IllegalArgumentException("safeTimeWithoutHeartbeat must be less than the lock's lease duration");
        }
    }
}
